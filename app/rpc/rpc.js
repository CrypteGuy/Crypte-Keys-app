// @flow
/* eslint-disable */
// Code generated by protoc-gen-jsrpc DO NOT EDIT.
// InputID: ac9cf07392272cead02f2ecf6c1e2f8716246b85
import {client} from './client'

import type {
  KeyGenerateRequest,
  KeyGenerateResponse,
  KeyRecoverRequest,
  KeyRecoverResponse,
  KeyBackupRequest,
  KeyBackupResponse,
  KeyRemoveRequest,
  KeyRemoveResponse,
  KeysRequest,
  KeysResponse,
  KeyRequest,
  KeyResponse,
  SignRequest,
  SignResponse,
  VerifyRequest,
  VerifyResponse,
  SignStreamInput,
  SignStreamOutput,
  VerifyStreamInput,
  VerifyStreamOutput,
  EncryptRequest,
  EncryptResponse,
  DecryptRequest,
  DecryptResponse,
  EncryptStreamInput,
  EncryptStreamOutput,
  DecryptStreamInput,
  DecryptStreamOutput,
  SigchainRequest,
  SigchainResponse,
  SigchainStatementCreateRequest,
  SigchainStatementCreateResponse,
  SigchainStatementRevokeRequest,
  SigchainStatementRevokeResponse,
  UserServiceRequest,
  UserServiceResponse,
  UserSignRequest,
  UserSignResponse,
  UserAddRequest,
  UserAddResponse,
  ItemRequest,
  ItemResponse,
  ItemsRequest,
  ItemsResponse,
  StatusRequest,
  StatusResponse,
  SearchRequest,
  SearchResponse,
  PullRequest,
  PullResponse,
  PushRequest,
  PushResponse,
  KeyShareRequest,
  KeyShareResponse,
  KeyRetrieveRequest,
  KeyRetrieveResponse,
  MessagePrepareRequest,
  MessagePrepareResponse,
  MessageCreateRequest,
  MessageCreateResponse,
  MessagesRequest,
  MessagesResponse,
  InboxRequest,
  InboxResponse,
  ConfigRequest,
  ConfigResponse,
  ConfigSetRequest,
  ConfigSetResponse,
  AuthSetupRequest,
  AuthSetupResponse,
  AuthUnlockRequest,
  AuthUnlockResponse,
  AuthLockRequest,
  AuthLockResponse,
  RuntimeStatusRequest,
  RuntimeStatusResponse,
  RandRequest,
  RandResponse,
  CollectionsRequest,
  CollectionsResponse,
  DocumentsRequest,
  DocumentsResponse,
  DocumentDeleteRequest,
  DocumentDeleteResponse,
  WatchRequest,
  WatchEvent
} from './types'

export type {
  KeyGenerateRequest,
  KeyGenerateResponse,
  KeyRecoverRequest,
  KeyRecoverResponse,
  KeyBackupRequest,
  KeyBackupResponse,
  KeyRemoveRequest,
  KeyRemoveResponse,
  KeysRequest,
  KeysResponse,
  KeyRequest,
  KeyResponse,
  SignRequest,
  SignResponse,
  VerifyRequest,
  VerifyResponse,
  SignStreamInput,
  SignStreamOutput,
  VerifyStreamInput,
  VerifyStreamOutput,
  EncryptRequest,
  EncryptResponse,
  DecryptRequest,
  DecryptResponse,
  EncryptStreamInput,
  EncryptStreamOutput,
  DecryptStreamInput,
  DecryptStreamOutput,
  SigchainRequest,
  SigchainResponse,
  SigchainStatementCreateRequest,
  SigchainStatementCreateResponse,
  SigchainStatementRevokeRequest,
  SigchainStatementRevokeResponse,
  UserServiceRequest,
  UserServiceResponse,
  UserSignRequest,
  UserSignResponse,
  UserAddRequest,
  UserAddResponse,
  ItemRequest,
  ItemResponse,
  ItemsRequest,
  ItemsResponse,
  StatusRequest,
  StatusResponse,
  SearchRequest,
  SearchResponse,
  PullRequest,
  PullResponse,
  PushRequest,
  PushResponse,
  KeyShareRequest,
  KeyShareResponse,
  KeyRetrieveRequest,
  KeyRetrieveResponse,
  MessagePrepareRequest,
  MessagePrepareResponse,
  MessageCreateRequest,
  MessageCreateResponse,
  MessagesRequest,
  MessagesResponse,
  InboxRequest,
  InboxResponse,
  ConfigRequest,
  ConfigResponse,
  ConfigSetRequest,
  ConfigSetResponse,
  AuthSetupRequest,
  AuthSetupResponse,
  AuthUnlockRequest,
  AuthUnlockResponse,
  AuthLockRequest,
  AuthLockResponse,
  RuntimeStatusRequest,
  RuntimeStatusResponse,
  RandRequest,
  RandResponse,
  CollectionsRequest,
  CollectionsResponse,
  DocumentsRequest,
  DocumentsResponse,
  DocumentDeleteRequest,
  DocumentDeleteResponse,
  WatchRequest,
  WatchEvent
}

export type RPCError = {
	code: number,
	message: string,
	details: string,
}

export const keyGenerate = (req: KeyGenerateRequest, respFn: ?(resp: KeyGenerateResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_GENERATE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.keyGenerate(req, (err: ?RPCError, resp: ?KeyGenerateResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY_GENERATE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_KEY_GENERATE_RESPONSE',
        payload: resp,
      })
    })
  }

export const keyRecover = (req: KeyRecoverRequest, respFn: ?(resp: KeyRecoverResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_RECOVER_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.keyRecover(req, (err: ?RPCError, resp: ?KeyRecoverResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY_RECOVER', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_KEY_RECOVER_RESPONSE',
        payload: resp,
      })
    })
  }

export const keyBackup = (req: KeyBackupRequest, respFn: ?(resp: KeyBackupResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_BACKUP_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.keyBackup(req, (err: ?RPCError, resp: ?KeyBackupResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY_BACKUP', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_KEY_BACKUP_RESPONSE',
        payload: resp,
      })
    })
  }

export const keyRemove = (req: KeyRemoveRequest, respFn: ?(resp: KeyRemoveResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_REMOVE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.keyRemove(req, (err: ?RPCError, resp: ?KeyRemoveResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY_REMOVE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_KEY_REMOVE_RESPONSE',
        payload: resp,
      })
    })
  }

export const keys = (req: KeysRequest, respFn: ?(resp: KeysResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEYS_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.keys(req, (err: ?RPCError, resp: ?KeysResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEYS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_KEYS_RESPONSE',
        payload: resp,
      })
    })
  }

export const key = (req: KeyRequest, respFn: ?(resp: KeyResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.key(req, (err: ?RPCError, resp: ?KeyResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_KEY_RESPONSE',
        payload: resp,
      })
    })
  }

export const sign = (req: SignRequest, respFn: ?(resp: SignResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGN_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.sign(req, (err: ?RPCError, resp: ?SignResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGN', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_SIGN_RESPONSE',
        payload: resp,
      })
    })
  }

export const verify = (req: VerifyRequest, respFn: ?(resp: VerifyResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_VERIFY_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.verify(req, (err: ?RPCError, resp: ?VerifyResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_VERIFY', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_VERIFY_RESPONSE',
        payload: resp,
      })
    })
  }

export const signStream = (req: SignStreamInput, respFn: ?(resp: SignStreamOutput) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGN_STREAM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.signStream(req, (err: ?RPCError, resp: ?SignStreamOutput) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGN_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_SIGN_STREAM_RESPONSE',
        payload: resp,
      })
    })
  }

export const verifyStream = (req: VerifyStreamInput, respFn: ?(resp: VerifyStreamOutput) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_VERIFY_STREAM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.verifyStream(req, (err: ?RPCError, resp: ?VerifyStreamOutput) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_VERIFY_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_VERIFY_STREAM_RESPONSE',
        payload: resp,
      })
    })
  }

export const verifyArmoredStream = (req: VerifyStreamInput, respFn: ?(resp: VerifyStreamOutput) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_VERIFY_ARMORED_STREAM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.verifyArmoredStream(req, (err: ?RPCError, resp: ?VerifyStreamOutput) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_VERIFY_ARMORED_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_VERIFY_ARMORED_STREAM_RESPONSE',
        payload: resp,
      })
    })
  }

export const encrypt = (req: EncryptRequest, respFn: ?(resp: EncryptResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_ENCRYPT_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.encrypt(req, (err: ?RPCError, resp: ?EncryptResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_ENCRYPT', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_ENCRYPT_RESPONSE',
        payload: resp,
      })
    })
  }

export const decrypt = (req: DecryptRequest, respFn: ?(resp: DecryptResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DECRYPT_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.decrypt(req, (err: ?RPCError, resp: ?DecryptResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DECRYPT', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_DECRYPT_RESPONSE',
        payload: resp,
      })
    })
  }

export const encryptStream = (req: EncryptStreamInput, respFn: ?(resp: EncryptStreamOutput) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_ENCRYPT_STREAM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.encryptStream(req, (err: ?RPCError, resp: ?EncryptStreamOutput) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_ENCRYPT_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_ENCRYPT_STREAM_RESPONSE',
        payload: resp,
      })
    })
  }

export const decryptStream = (req: DecryptStreamInput, respFn: ?(resp: DecryptStreamOutput) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DECRYPT_STREAM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.decryptStream(req, (err: ?RPCError, resp: ?DecryptStreamOutput) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DECRYPT_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_DECRYPT_STREAM_RESPONSE',
        payload: resp,
      })
    })
  }

export const decryptArmoredStream = (req: DecryptStreamInput, respFn: ?(resp: DecryptStreamOutput) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DECRYPT_ARMORED_STREAM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.decryptArmoredStream(req, (err: ?RPCError, resp: ?DecryptStreamOutput) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DECRYPT_ARMORED_STREAM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_DECRYPT_ARMORED_STREAM_RESPONSE',
        payload: resp,
      })
    })
  }

export const sigchain = (req: SigchainRequest, respFn: ?(resp: SigchainResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGCHAIN_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.sigchain(req, (err: ?RPCError, resp: ?SigchainResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGCHAIN', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_SIGCHAIN_RESPONSE',
        payload: resp,
      })
    })
  }

export const sigchainStatementCreate = (req: SigchainStatementCreateRequest, respFn: ?(resp: SigchainStatementCreateResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGCHAIN_STATEMENT_CREATE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.sigchainStatementCreate(req, (err: ?RPCError, resp: ?SigchainStatementCreateResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGCHAIN_STATEMENT_CREATE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_SIGCHAIN_STATEMENT_CREATE_RESPONSE',
        payload: resp,
      })
    })
  }

export const sigchainStatementRevoke = (req: SigchainStatementRevokeRequest, respFn: ?(resp: SigchainStatementRevokeResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SIGCHAIN_STATEMENT_REVOKE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.sigchainStatementRevoke(req, (err: ?RPCError, resp: ?SigchainStatementRevokeResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SIGCHAIN_STATEMENT_REVOKE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_SIGCHAIN_STATEMENT_REVOKE_RESPONSE',
        payload: resp,
      })
    })
  }

export const userService = (req: UserServiceRequest, respFn: ?(resp: UserServiceResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_USER_SERVICE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.userService(req, (err: ?RPCError, resp: ?UserServiceResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_USER_SERVICE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_USER_SERVICE_RESPONSE',
        payload: resp,
      })
    })
  }

export const userSign = (req: UserSignRequest, respFn: ?(resp: UserSignResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_USER_SIGN_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.userSign(req, (err: ?RPCError, resp: ?UserSignResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_USER_SIGN', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_USER_SIGN_RESPONSE',
        payload: resp,
      })
    })
  }

export const userAdd = (req: UserAddRequest, respFn: ?(resp: UserAddResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_USER_ADD_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.userAdd(req, (err: ?RPCError, resp: ?UserAddResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_USER_ADD', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_USER_ADD_RESPONSE',
        payload: resp,
      })
    })
  }

export const item = (req: ItemRequest, respFn: ?(resp: ItemResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_ITEM_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.item(req, (err: ?RPCError, resp: ?ItemResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_ITEM', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_ITEM_RESPONSE',
        payload: resp,
      })
    })
  }

export const items = (req: ItemsRequest, respFn: ?(resp: ItemsResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_ITEMS_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.items(req, (err: ?RPCError, resp: ?ItemsResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_ITEMS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_ITEMS_RESPONSE',
        payload: resp,
      })
    })
  }

export const status = (req: StatusRequest, respFn: ?(resp: StatusResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_STATUS_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.status(req, (err: ?RPCError, resp: ?StatusResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_STATUS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_STATUS_RESPONSE',
        payload: resp,
      })
    })
  }

export const search = (req: SearchRequest, respFn: ?(resp: SearchResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_SEARCH_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.search(req, (err: ?RPCError, resp: ?SearchResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_SEARCH', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_SEARCH_RESPONSE',
        payload: resp,
      })
    })
  }

export const pull = (req: PullRequest, respFn: ?(resp: PullResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_PULL_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.pull(req, (err: ?RPCError, resp: ?PullResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_PULL', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_PULL_RESPONSE',
        payload: resp,
      })
    })
  }

export const push = (req: PushRequest, respFn: ?(resp: PushResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_PUSH_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.push(req, (err: ?RPCError, resp: ?PushResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_PUSH', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_PUSH_RESPONSE',
        payload: resp,
      })
    })
  }

export const keyShare = (req: KeyShareRequest, respFn: ?(resp: KeyShareResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_SHARE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.keyShare(req, (err: ?RPCError, resp: ?KeyShareResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY_SHARE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_KEY_SHARE_RESPONSE',
        payload: resp,
      })
    })
  }

export const keyRetrieve = (req: KeyRetrieveRequest, respFn: ?(resp: KeyRetrieveResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_KEY_RETRIEVE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.keyRetrieve(req, (err: ?RPCError, resp: ?KeyRetrieveResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_KEY_RETRIEVE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_KEY_RETRIEVE_RESPONSE',
        payload: resp,
      })
    })
  }

export const messagePrepare = (req: MessagePrepareRequest, respFn: ?(resp: MessagePrepareResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_MESSAGE_PREPARE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.messagePrepare(req, (err: ?RPCError, resp: ?MessagePrepareResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_MESSAGE_PREPARE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_MESSAGE_PREPARE_RESPONSE',
        payload: resp,
      })
    })
  }

export const messageCreate = (req: MessageCreateRequest, respFn: ?(resp: MessageCreateResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_MESSAGE_CREATE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.messageCreate(req, (err: ?RPCError, resp: ?MessageCreateResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_MESSAGE_CREATE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_MESSAGE_CREATE_RESPONSE',
        payload: resp,
      })
    })
  }

export const messages = (req: MessagesRequest, respFn: ?(resp: MessagesResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_MESSAGES_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.messages(req, (err: ?RPCError, resp: ?MessagesResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_MESSAGES', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_MESSAGES_RESPONSE',
        payload: resp,
      })
    })
  }

export const inbox = (req: InboxRequest, respFn: ?(resp: InboxResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_INBOX_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.inbox(req, (err: ?RPCError, resp: ?InboxResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_INBOX', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_INBOX_RESPONSE',
        payload: resp,
      })
    })
  }

export const config = (req: ConfigRequest, respFn: ?(resp: ConfigResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_CONFIG_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.config(req, (err: ?RPCError, resp: ?ConfigResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_CONFIG', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_CONFIG_RESPONSE',
        payload: resp,
      })
    })
  }

export const configSet = (req: ConfigSetRequest, respFn: ?(resp: ConfigSetResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_CONFIG_SET_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.configSet(req, (err: ?RPCError, resp: ?ConfigSetResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_CONFIG_SET', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_CONFIG_SET_RESPONSE',
        payload: resp,
      })
    })
  }

export const authSetup = (req: AuthSetupRequest, respFn: ?(resp: AuthSetupResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_AUTH_SETUP_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.authSetup(req, (err: ?RPCError, resp: ?AuthSetupResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_AUTH_SETUP', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_AUTH_SETUP_RESPONSE',
        payload: resp,
      })
    })
  }

export const authUnlock = (req: AuthUnlockRequest, respFn: ?(resp: AuthUnlockResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_AUTH_UNLOCK_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.authUnlock(req, (err: ?RPCError, resp: ?AuthUnlockResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_AUTH_UNLOCK', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_AUTH_UNLOCK_RESPONSE',
        payload: resp,
      })
    })
  }

export const authLock = (req: AuthLockRequest, respFn: ?(resp: AuthLockResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_AUTH_LOCK_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.authLock(req, (err: ?RPCError, resp: ?AuthLockResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_AUTH_LOCK', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_AUTH_LOCK_RESPONSE',
        payload: resp,
      })
    })
  }

export const runtimeStatus = (req: RuntimeStatusRequest, respFn: ?(resp: RuntimeStatusResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_RUNTIME_STATUS_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.runtimeStatus(req, (err: ?RPCError, resp: ?RuntimeStatusResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_RUNTIME_STATUS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_RUNTIME_STATUS_RESPONSE',
        payload: resp,
      })
    })
  }

export const rand = (req: RandRequest, respFn: ?(resp: RandResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_RAND_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.rand(req, (err: ?RPCError, resp: ?RandResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_RAND', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_RAND_RESPONSE',
        payload: resp,
      })
    })
  }

export const collections = (req: CollectionsRequest, respFn: ?(resp: CollectionsResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_COLLECTIONS_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.collections(req, (err: ?RPCError, resp: ?CollectionsResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_COLLECTIONS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_COLLECTIONS_RESPONSE',
        payload: resp,
      })
    })
  }

export const documents = (req: DocumentsRequest, respFn: ?(resp: DocumentsResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DOCUMENTS_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.documents(req, (err: ?RPCError, resp: ?DocumentsResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DOCUMENTS', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_DOCUMENTS_RESPONSE',
        payload: resp,
      })
    })
  }

export const documentDelete = (req: DocumentDeleteRequest, respFn: ?(resp: DocumentDeleteResponse) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_DOCUMENT_DELETE_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.documentDelete(req, (err: ?RPCError, resp: ?DocumentDeleteResponse) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_DOCUMENT_DELETE', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_DOCUMENT_DELETE_RESPONSE',
        payload: resp,
      })
    })
  }

export const watch = (req: WatchRequest, respFn: ?(resp: WatchEvent) => void, errFn: ?(err: RPCError) => void) => async (dispatch: (action: any) => void) => {
  dispatch({
    type: 'KEYS_WATCH_REQUEST',
		payload: req,
	})
	let cl = await client()
  cl.watch(req, (err: ?RPCError, resp: ?WatchEvent) => {
    if (err) {
      if (errFn) {
        console.error(err)
        errFn(err)
      } else if (errHandler) {
        errHandler(err)
      } else {
        dispatch({
          type: 'ERROR',
          payload: {error: err, action: 'KEYS_WATCH', req},
        })
      }
      return
    }
    if (resp && respFn) respFn(resp)
      dispatch({
        type: 'KEYS_WATCH_RESPONSE',
        payload: resp,
      })
    })
  }



export const RPC = {
  keyGenerate,
  keyRecover,
  keyBackup,
  keyRemove,
  keys,
  key,
  sign,
  verify,
  signStream,
  verifyStream,
  verifyArmoredStream,
  encrypt,
  decrypt,
  encryptStream,
  decryptStream,
  decryptArmoredStream,
  sigchain,
  sigchainStatementCreate,
  sigchainStatementRevoke,
  userService,
  userSign,
  userAdd,
  item,
  items,
  status,
  search,
  pull,
  push,
  keyShare,
  keyRetrieve,
  messagePrepare,
  messageCreate,
  messages,
  inbox,
  config,
  configSet,
  authSetup,
  authUnlock,
  authLock,
  runtimeStatus,
  rand,
  collections,
  documents,
  documentDelete,
  watch
}

export type RPCState = {
  keyGenerateLoading: boolean,
  keyGenerateRequest: ?KeyGenerateRequest,
  keyGenerate: ?KeyGenerateResponse,
  keyRecoverLoading: boolean,
  keyRecoverRequest: ?KeyRecoverRequest,
  keyRecover: ?KeyRecoverResponse,
  keyBackupLoading: boolean,
  keyBackupRequest: ?KeyBackupRequest,
  keyBackup: ?KeyBackupResponse,
  keyRemoveLoading: boolean,
  keyRemoveRequest: ?KeyRemoveRequest,
  keyRemove: ?KeyRemoveResponse,
  keysLoading: boolean,
  keysRequest: ?KeysRequest,
  keys: ?KeysResponse,
  keyLoading: boolean,
  keyRequest: ?KeyRequest,
  key: ?KeyResponse,
  signLoading: boolean,
  signRequest: ?SignRequest,
  sign: ?SignResponse,
  verifyLoading: boolean,
  verifyRequest: ?VerifyRequest,
  verify: ?VerifyResponse,
  signStreamLoading: boolean,
  signStreamRequest: ?SignStreamInput,
  signStream: ?SignStreamOutput,
  verifyStreamLoading: boolean,
  verifyStreamRequest: ?VerifyStreamInput,
  verifyStream: ?VerifyStreamOutput,
  verifyArmoredStreamLoading: boolean,
  verifyArmoredStreamRequest: ?VerifyStreamInput,
  verifyArmoredStream: ?VerifyStreamOutput,
  encryptLoading: boolean,
  encryptRequest: ?EncryptRequest,
  encrypt: ?EncryptResponse,
  decryptLoading: boolean,
  decryptRequest: ?DecryptRequest,
  decrypt: ?DecryptResponse,
  encryptStreamLoading: boolean,
  encryptStreamRequest: ?EncryptStreamInput,
  encryptStream: ?EncryptStreamOutput,
  decryptStreamLoading: boolean,
  decryptStreamRequest: ?DecryptStreamInput,
  decryptStream: ?DecryptStreamOutput,
  decryptArmoredStreamLoading: boolean,
  decryptArmoredStreamRequest: ?DecryptStreamInput,
  decryptArmoredStream: ?DecryptStreamOutput,
  sigchainLoading: boolean,
  sigchainRequest: ?SigchainRequest,
  sigchain: ?SigchainResponse,
  sigchainStatementCreateLoading: boolean,
  sigchainStatementCreateRequest: ?SigchainStatementCreateRequest,
  sigchainStatementCreate: ?SigchainStatementCreateResponse,
  sigchainStatementRevokeLoading: boolean,
  sigchainStatementRevokeRequest: ?SigchainStatementRevokeRequest,
  sigchainStatementRevoke: ?SigchainStatementRevokeResponse,
  userServiceLoading: boolean,
  userServiceRequest: ?UserServiceRequest,
  userService: ?UserServiceResponse,
  userSignLoading: boolean,
  userSignRequest: ?UserSignRequest,
  userSign: ?UserSignResponse,
  userAddLoading: boolean,
  userAddRequest: ?UserAddRequest,
  userAdd: ?UserAddResponse,
  itemLoading: boolean,
  itemRequest: ?ItemRequest,
  item: ?ItemResponse,
  itemsLoading: boolean,
  itemsRequest: ?ItemsRequest,
  items: ?ItemsResponse,
  statusLoading: boolean,
  statusRequest: ?StatusRequest,
  status: ?StatusResponse,
  searchLoading: boolean,
  searchRequest: ?SearchRequest,
  search: ?SearchResponse,
  pullLoading: boolean,
  pullRequest: ?PullRequest,
  pull: ?PullResponse,
  pushLoading: boolean,
  pushRequest: ?PushRequest,
  push: ?PushResponse,
  keyShareLoading: boolean,
  keyShareRequest: ?KeyShareRequest,
  keyShare: ?KeyShareResponse,
  keyRetrieveLoading: boolean,
  keyRetrieveRequest: ?KeyRetrieveRequest,
  keyRetrieve: ?KeyRetrieveResponse,
  messagePrepareLoading: boolean,
  messagePrepareRequest: ?MessagePrepareRequest,
  messagePrepare: ?MessagePrepareResponse,
  messageCreateLoading: boolean,
  messageCreateRequest: ?MessageCreateRequest,
  messageCreate: ?MessageCreateResponse,
  messagesLoading: boolean,
  messagesRequest: ?MessagesRequest,
  messages: ?MessagesResponse,
  inboxLoading: boolean,
  inboxRequest: ?InboxRequest,
  inbox: ?InboxResponse,
  configLoading: boolean,
  configRequest: ?ConfigRequest,
  config: ?ConfigResponse,
  configSetLoading: boolean,
  configSetRequest: ?ConfigSetRequest,
  configSet: ?ConfigSetResponse,
  authSetupLoading: boolean,
  authSetupRequest: ?AuthSetupRequest,
  authSetup: ?AuthSetupResponse,
  authUnlockLoading: boolean,
  authUnlockRequest: ?AuthUnlockRequest,
  authUnlock: ?AuthUnlockResponse,
  authLockLoading: boolean,
  authLockRequest: ?AuthLockRequest,
  authLock: ?AuthLockResponse,
  runtimeStatusLoading: boolean,
  runtimeStatusRequest: ?RuntimeStatusRequest,
  runtimeStatus: ?RuntimeStatusResponse,
  randLoading: boolean,
  randRequest: ?RandRequest,
  rand: ?RandResponse,
  collectionsLoading: boolean,
  collectionsRequest: ?CollectionsRequest,
  collections: ?CollectionsResponse,
  documentsLoading: boolean,
  documentsRequest: ?DocumentsRequest,
  documents: ?DocumentsResponse,
  documentDeleteLoading: boolean,
  documentDeleteRequest: ?DocumentDeleteRequest,
  documentDelete: ?DocumentDeleteResponse,
  watchLoading: boolean,
  watchRequest: ?WatchRequest,
  watch: ?WatchEvent
}

const initialState: RPCState = {
  keyGenerateLoading: false,
  keyGenerateRequest: null,
  keyGenerate: null,
  keyRecoverLoading: false,
  keyRecoverRequest: null,
  keyRecover: null,
  keyBackupLoading: false,
  keyBackupRequest: null,
  keyBackup: null,
  keyRemoveLoading: false,
  keyRemoveRequest: null,
  keyRemove: null,
  keysLoading: false,
  keysRequest: null,
  keys: null,
  keyLoading: false,
  keyRequest: null,
  key: null,
  signLoading: false,
  signRequest: null,
  sign: null,
  verifyLoading: false,
  verifyRequest: null,
  verify: null,
  signStreamLoading: false,
  signStreamRequest: null,
  signStream: null,
  verifyStreamLoading: false,
  verifyStreamRequest: null,
  verifyStream: null,
  verifyArmoredStreamLoading: false,
  verifyArmoredStreamRequest: null,
  verifyArmoredStream: null,
  encryptLoading: false,
  encryptRequest: null,
  encrypt: null,
  decryptLoading: false,
  decryptRequest: null,
  decrypt: null,
  encryptStreamLoading: false,
  encryptStreamRequest: null,
  encryptStream: null,
  decryptStreamLoading: false,
  decryptStreamRequest: null,
  decryptStream: null,
  decryptArmoredStreamLoading: false,
  decryptArmoredStreamRequest: null,
  decryptArmoredStream: null,
  sigchainLoading: false,
  sigchainRequest: null,
  sigchain: null,
  sigchainStatementCreateLoading: false,
  sigchainStatementCreateRequest: null,
  sigchainStatementCreate: null,
  sigchainStatementRevokeLoading: false,
  sigchainStatementRevokeRequest: null,
  sigchainStatementRevoke: null,
  userServiceLoading: false,
  userServiceRequest: null,
  userService: null,
  userSignLoading: false,
  userSignRequest: null,
  userSign: null,
  userAddLoading: false,
  userAddRequest: null,
  userAdd: null,
  itemLoading: false,
  itemRequest: null,
  item: null,
  itemsLoading: false,
  itemsRequest: null,
  items: null,
  statusLoading: false,
  statusRequest: null,
  status: null,
  searchLoading: false,
  searchRequest: null,
  search: null,
  pullLoading: false,
  pullRequest: null,
  pull: null,
  pushLoading: false,
  pushRequest: null,
  push: null,
  keyShareLoading: false,
  keyShareRequest: null,
  keyShare: null,
  keyRetrieveLoading: false,
  keyRetrieveRequest: null,
  keyRetrieve: null,
  messagePrepareLoading: false,
  messagePrepareRequest: null,
  messagePrepare: null,
  messageCreateLoading: false,
  messageCreateRequest: null,
  messageCreate: null,
  messagesLoading: false,
  messagesRequest: null,
  messages: null,
  inboxLoading: false,
  inboxRequest: null,
  inbox: null,
  configLoading: false,
  configRequest: null,
  config: null,
  configSetLoading: false,
  configSetRequest: null,
  configSet: null,
  authSetupLoading: false,
  authSetupRequest: null,
  authSetup: null,
  authUnlockLoading: false,
  authUnlockRequest: null,
  authUnlock: null,
  authLockLoading: false,
  authLockRequest: null,
  authLock: null,
  runtimeStatusLoading: false,
  runtimeStatusRequest: null,
  runtimeStatus: null,
  randLoading: false,
  randRequest: null,
  rand: null,
  collectionsLoading: false,
  collectionsRequest: null,
  collections: null,
  documentsLoading: false,
  documentsRequest: null,
  documents: null,
  documentDeleteLoading: false,
  documentDeleteRequest: null,
  documentDelete: null,
  watchLoading: false,
  watchRequest: null,
  watch: null
}

export const reducer = (state: RPCState = initialState, action: any) => {
  switch (action.type) {
		case 'KEYS_KEY_GENERATE_REQUEST': {
			return {
				...state,
				keyGenerateLoading: false,
				keyGenerateRequest: action.payload,
		  }
		}
		case 'KEYS_KEY_GENERATE_RESPONSE': {
			return {
				...state,
				keyGenerateLoading: false,
				keyGenerateRequest: null,
				keyGenerate: action.payload,
			}
		}
    
		case 'KEYS_KEY_RECOVER_REQUEST': {
			return {
				...state,
				keyRecoverLoading: false,
				keyRecoverRequest: action.payload,
		  }
		}
		case 'KEYS_KEY_RECOVER_RESPONSE': {
			return {
				...state,
				keyRecoverLoading: false,
				keyRecoverRequest: null,
				keyRecover: action.payload,
			}
		}
    
		case 'KEYS_KEY_BACKUP_REQUEST': {
			return {
				...state,
				keyBackupLoading: false,
				keyBackupRequest: action.payload,
		  }
		}
		case 'KEYS_KEY_BACKUP_RESPONSE': {
			return {
				...state,
				keyBackupLoading: false,
				keyBackupRequest: null,
				keyBackup: action.payload,
			}
		}
    
		case 'KEYS_KEY_REMOVE_REQUEST': {
			return {
				...state,
				keyRemoveLoading: false,
				keyRemoveRequest: action.payload,
		  }
		}
		case 'KEYS_KEY_REMOVE_RESPONSE': {
			return {
				...state,
				keyRemoveLoading: false,
				keyRemoveRequest: null,
				keyRemove: action.payload,
			}
		}
    
		case 'KEYS_KEYS_REQUEST': {
			return {
				...state,
				keysLoading: false,
				keysRequest: action.payload,
		  }
		}
		case 'KEYS_KEYS_RESPONSE': {
			return {
				...state,
				keysLoading: false,
				keysRequest: null,
				keys: action.payload,
			}
		}
    
		case 'KEYS_KEY_REQUEST': {
			return {
				...state,
				keyLoading: false,
				keyRequest: action.payload,
		  }
		}
		case 'KEYS_KEY_RESPONSE': {
			return {
				...state,
				keyLoading: false,
				keyRequest: null,
				key: action.payload,
			}
		}
    
		case 'KEYS_SIGN_REQUEST': {
			return {
				...state,
				signLoading: false,
				signRequest: action.payload,
		  }
		}
		case 'KEYS_SIGN_RESPONSE': {
			return {
				...state,
				signLoading: false,
				signRequest: null,
				sign: action.payload,
			}
		}
    
		case 'KEYS_VERIFY_REQUEST': {
			return {
				...state,
				verifyLoading: false,
				verifyRequest: action.payload,
		  }
		}
		case 'KEYS_VERIFY_RESPONSE': {
			return {
				...state,
				verifyLoading: false,
				verifyRequest: null,
				verify: action.payload,
			}
		}
    
		case 'KEYS_SIGN_STREAM_REQUEST': {
			return {
				...state,
				signStreamLoading: false,
				signStreamRequest: action.payload,
		  }
		}
		case 'KEYS_SIGN_STREAM_RESPONSE': {
			return {
				...state,
				signStreamLoading: false,
				signStreamRequest: null,
				signStream: action.payload,
			}
		}
    
		case 'KEYS_VERIFY_STREAM_REQUEST': {
			return {
				...state,
				verifyStreamLoading: false,
				verifyStreamRequest: action.payload,
		  }
		}
		case 'KEYS_VERIFY_STREAM_RESPONSE': {
			return {
				...state,
				verifyStreamLoading: false,
				verifyStreamRequest: null,
				verifyStream: action.payload,
			}
		}
    
		case 'KEYS_VERIFY_ARMORED_STREAM_REQUEST': {
			return {
				...state,
				verifyArmoredStreamLoading: false,
				verifyArmoredStreamRequest: action.payload,
		  }
		}
		case 'KEYS_VERIFY_ARMORED_STREAM_RESPONSE': {
			return {
				...state,
				verifyArmoredStreamLoading: false,
				verifyArmoredStreamRequest: null,
				verifyArmoredStream: action.payload,
			}
		}
    
		case 'KEYS_ENCRYPT_REQUEST': {
			return {
				...state,
				encryptLoading: false,
				encryptRequest: action.payload,
		  }
		}
		case 'KEYS_ENCRYPT_RESPONSE': {
			return {
				...state,
				encryptLoading: false,
				encryptRequest: null,
				encrypt: action.payload,
			}
		}
    
		case 'KEYS_DECRYPT_REQUEST': {
			return {
				...state,
				decryptLoading: false,
				decryptRequest: action.payload,
		  }
		}
		case 'KEYS_DECRYPT_RESPONSE': {
			return {
				...state,
				decryptLoading: false,
				decryptRequest: null,
				decrypt: action.payload,
			}
		}
    
		case 'KEYS_ENCRYPT_STREAM_REQUEST': {
			return {
				...state,
				encryptStreamLoading: false,
				encryptStreamRequest: action.payload,
		  }
		}
		case 'KEYS_ENCRYPT_STREAM_RESPONSE': {
			return {
				...state,
				encryptStreamLoading: false,
				encryptStreamRequest: null,
				encryptStream: action.payload,
			}
		}
    
		case 'KEYS_DECRYPT_STREAM_REQUEST': {
			return {
				...state,
				decryptStreamLoading: false,
				decryptStreamRequest: action.payload,
		  }
		}
		case 'KEYS_DECRYPT_STREAM_RESPONSE': {
			return {
				...state,
				decryptStreamLoading: false,
				decryptStreamRequest: null,
				decryptStream: action.payload,
			}
		}
    
		case 'KEYS_DECRYPT_ARMORED_STREAM_REQUEST': {
			return {
				...state,
				decryptArmoredStreamLoading: false,
				decryptArmoredStreamRequest: action.payload,
		  }
		}
		case 'KEYS_DECRYPT_ARMORED_STREAM_RESPONSE': {
			return {
				...state,
				decryptArmoredStreamLoading: false,
				decryptArmoredStreamRequest: null,
				decryptArmoredStream: action.payload,
			}
		}
    
		case 'KEYS_SIGCHAIN_REQUEST': {
			return {
				...state,
				sigchainLoading: false,
				sigchainRequest: action.payload,
		  }
		}
		case 'KEYS_SIGCHAIN_RESPONSE': {
			return {
				...state,
				sigchainLoading: false,
				sigchainRequest: null,
				sigchain: action.payload,
			}
		}
    
		case 'KEYS_SIGCHAIN_STATEMENT_CREATE_REQUEST': {
			return {
				...state,
				sigchainStatementCreateLoading: false,
				sigchainStatementCreateRequest: action.payload,
		  }
		}
		case 'KEYS_SIGCHAIN_STATEMENT_CREATE_RESPONSE': {
			return {
				...state,
				sigchainStatementCreateLoading: false,
				sigchainStatementCreateRequest: null,
				sigchainStatementCreate: action.payload,
			}
		}
    
		case 'KEYS_SIGCHAIN_STATEMENT_REVOKE_REQUEST': {
			return {
				...state,
				sigchainStatementRevokeLoading: false,
				sigchainStatementRevokeRequest: action.payload,
		  }
		}
		case 'KEYS_SIGCHAIN_STATEMENT_REVOKE_RESPONSE': {
			return {
				...state,
				sigchainStatementRevokeLoading: false,
				sigchainStatementRevokeRequest: null,
				sigchainStatementRevoke: action.payload,
			}
		}
    
		case 'KEYS_USER_SERVICE_REQUEST': {
			return {
				...state,
				userServiceLoading: false,
				userServiceRequest: action.payload,
		  }
		}
		case 'KEYS_USER_SERVICE_RESPONSE': {
			return {
				...state,
				userServiceLoading: false,
				userServiceRequest: null,
				userService: action.payload,
			}
		}
    
		case 'KEYS_USER_SIGN_REQUEST': {
			return {
				...state,
				userSignLoading: false,
				userSignRequest: action.payload,
		  }
		}
		case 'KEYS_USER_SIGN_RESPONSE': {
			return {
				...state,
				userSignLoading: false,
				userSignRequest: null,
				userSign: action.payload,
			}
		}
    
		case 'KEYS_USER_ADD_REQUEST': {
			return {
				...state,
				userAddLoading: false,
				userAddRequest: action.payload,
		  }
		}
		case 'KEYS_USER_ADD_RESPONSE': {
			return {
				...state,
				userAddLoading: false,
				userAddRequest: null,
				userAdd: action.payload,
			}
		}
    
		case 'KEYS_ITEM_REQUEST': {
			return {
				...state,
				itemLoading: false,
				itemRequest: action.payload,
		  }
		}
		case 'KEYS_ITEM_RESPONSE': {
			return {
				...state,
				itemLoading: false,
				itemRequest: null,
				item: action.payload,
			}
		}
    
		case 'KEYS_ITEMS_REQUEST': {
			return {
				...state,
				itemsLoading: false,
				itemsRequest: action.payload,
		  }
		}
		case 'KEYS_ITEMS_RESPONSE': {
			return {
				...state,
				itemsLoading: false,
				itemsRequest: null,
				items: action.payload,
			}
		}
    
		case 'KEYS_STATUS_REQUEST': {
			return {
				...state,
				statusLoading: false,
				statusRequest: action.payload,
		  }
		}
		case 'KEYS_STATUS_RESPONSE': {
			return {
				...state,
				statusLoading: false,
				statusRequest: null,
				status: action.payload,
			}
		}
    
		case 'KEYS_SEARCH_REQUEST': {
			return {
				...state,
				searchLoading: false,
				searchRequest: action.payload,
		  }
		}
		case 'KEYS_SEARCH_RESPONSE': {
			return {
				...state,
				searchLoading: false,
				searchRequest: null,
				search: action.payload,
			}
		}
    
		case 'KEYS_PULL_REQUEST': {
			return {
				...state,
				pullLoading: false,
				pullRequest: action.payload,
		  }
		}
		case 'KEYS_PULL_RESPONSE': {
			return {
				...state,
				pullLoading: false,
				pullRequest: null,
				pull: action.payload,
			}
		}
    
		case 'KEYS_PUSH_REQUEST': {
			return {
				...state,
				pushLoading: false,
				pushRequest: action.payload,
		  }
		}
		case 'KEYS_PUSH_RESPONSE': {
			return {
				...state,
				pushLoading: false,
				pushRequest: null,
				push: action.payload,
			}
		}
    
		case 'KEYS_KEY_SHARE_REQUEST': {
			return {
				...state,
				keyShareLoading: false,
				keyShareRequest: action.payload,
		  }
		}
		case 'KEYS_KEY_SHARE_RESPONSE': {
			return {
				...state,
				keyShareLoading: false,
				keyShareRequest: null,
				keyShare: action.payload,
			}
		}
    
		case 'KEYS_KEY_RETRIEVE_REQUEST': {
			return {
				...state,
				keyRetrieveLoading: false,
				keyRetrieveRequest: action.payload,
		  }
		}
		case 'KEYS_KEY_RETRIEVE_RESPONSE': {
			return {
				...state,
				keyRetrieveLoading: false,
				keyRetrieveRequest: null,
				keyRetrieve: action.payload,
			}
		}
    
		case 'KEYS_MESSAGE_PREPARE_REQUEST': {
			return {
				...state,
				messagePrepareLoading: false,
				messagePrepareRequest: action.payload,
		  }
		}
		case 'KEYS_MESSAGE_PREPARE_RESPONSE': {
			return {
				...state,
				messagePrepareLoading: false,
				messagePrepareRequest: null,
				messagePrepare: action.payload,
			}
		}
    
		case 'KEYS_MESSAGE_CREATE_REQUEST': {
			return {
				...state,
				messageCreateLoading: false,
				messageCreateRequest: action.payload,
		  }
		}
		case 'KEYS_MESSAGE_CREATE_RESPONSE': {
			return {
				...state,
				messageCreateLoading: false,
				messageCreateRequest: null,
				messageCreate: action.payload,
			}
		}
    
		case 'KEYS_MESSAGES_REQUEST': {
			return {
				...state,
				messagesLoading: false,
				messagesRequest: action.payload,
		  }
		}
		case 'KEYS_MESSAGES_RESPONSE': {
			return {
				...state,
				messagesLoading: false,
				messagesRequest: null,
				messages: action.payload,
			}
		}
    
		case 'KEYS_INBOX_REQUEST': {
			return {
				...state,
				inboxLoading: false,
				inboxRequest: action.payload,
		  }
		}
		case 'KEYS_INBOX_RESPONSE': {
			return {
				...state,
				inboxLoading: false,
				inboxRequest: null,
				inbox: action.payload,
			}
		}
    
		case 'KEYS_CONFIG_REQUEST': {
			return {
				...state,
				configLoading: false,
				configRequest: action.payload,
		  }
		}
		case 'KEYS_CONFIG_RESPONSE': {
			return {
				...state,
				configLoading: false,
				configRequest: null,
				config: action.payload,
			}
		}
    
		case 'KEYS_CONFIG_SET_REQUEST': {
			return {
				...state,
				configSetLoading: false,
				configSetRequest: action.payload,
		  }
		}
		case 'KEYS_CONFIG_SET_RESPONSE': {
			return {
				...state,
				configSetLoading: false,
				configSetRequest: null,
				configSet: action.payload,
			}
		}
    
		case 'KEYS_AUTH_SETUP_REQUEST': {
			return {
				...state,
				authSetupLoading: false,
				authSetupRequest: action.payload,
		  }
		}
		case 'KEYS_AUTH_SETUP_RESPONSE': {
			return {
				...state,
				authSetupLoading: false,
				authSetupRequest: null,
				authSetup: action.payload,
			}
		}
    
		case 'KEYS_AUTH_UNLOCK_REQUEST': {
			return {
				...state,
				authUnlockLoading: false,
				authUnlockRequest: action.payload,
		  }
		}
		case 'KEYS_AUTH_UNLOCK_RESPONSE': {
			return {
				...state,
				authUnlockLoading: false,
				authUnlockRequest: null,
				authUnlock: action.payload,
			}
		}
    
		case 'KEYS_AUTH_LOCK_REQUEST': {
			return {
				...state,
				authLockLoading: false,
				authLockRequest: action.payload,
		  }
		}
		case 'KEYS_AUTH_LOCK_RESPONSE': {
			return {
				...state,
				authLockLoading: false,
				authLockRequest: null,
				authLock: action.payload,
			}
		}
    
		case 'KEYS_RUNTIME_STATUS_REQUEST': {
			return {
				...state,
				runtimeStatusLoading: false,
				runtimeStatusRequest: action.payload,
		  }
		}
		case 'KEYS_RUNTIME_STATUS_RESPONSE': {
			return {
				...state,
				runtimeStatusLoading: false,
				runtimeStatusRequest: null,
				runtimeStatus: action.payload,
			}
		}
    
		case 'KEYS_RAND_REQUEST': {
			return {
				...state,
				randLoading: false,
				randRequest: action.payload,
		  }
		}
		case 'KEYS_RAND_RESPONSE': {
			return {
				...state,
				randLoading: false,
				randRequest: null,
				rand: action.payload,
			}
		}
    
		case 'KEYS_COLLECTIONS_REQUEST': {
			return {
				...state,
				collectionsLoading: false,
				collectionsRequest: action.payload,
		  }
		}
		case 'KEYS_COLLECTIONS_RESPONSE': {
			return {
				...state,
				collectionsLoading: false,
				collectionsRequest: null,
				collections: action.payload,
			}
		}
    
		case 'KEYS_DOCUMENTS_REQUEST': {
			return {
				...state,
				documentsLoading: false,
				documentsRequest: action.payload,
		  }
		}
		case 'KEYS_DOCUMENTS_RESPONSE': {
			return {
				...state,
				documentsLoading: false,
				documentsRequest: null,
				documents: action.payload,
			}
		}
    
		case 'KEYS_DOCUMENT_DELETE_REQUEST': {
			return {
				...state,
				documentDeleteLoading: false,
				documentDeleteRequest: action.payload,
		  }
		}
		case 'KEYS_DOCUMENT_DELETE_RESPONSE': {
			return {
				...state,
				documentDeleteLoading: false,
				documentDeleteRequest: null,
				documentDelete: action.payload,
			}
		}
    
		case 'KEYS_WATCH_REQUEST': {
			return {
				...state,
				watchLoading: false,
				watchRequest: action.payload,
		  }
		}
		case 'KEYS_WATCH_RESPONSE': {
			return {
				...state,
				watchLoading: false,
				watchRequest: null,
				watch: action.payload,
			}
		}
    default:
      return state
  }
}

export type ErrHandler = (err: RPCError) => void
var errHandler: ?ErrHandler = null
export const setErrHandler = (eh: ?ErrHandler) => {
  errHandler = eh
}

